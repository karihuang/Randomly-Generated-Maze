# Introduction
This is a group project written in C# and the maze was created in Unity. I was in charge of building up the environment, implementing the functionality of the player and participating in the discussion of the binary tree pseudocode.

# Description
Creating the maze utilizes the coding and random elements of computational media the most, and draws on the design aspect slightly. Although our algorithm is one of the simpler ones to generate a maze, it was still complicated to implement and get working properly. Within the binary tree algorithm, we do take advantage of random number generation. This ensures that every maze will be unique and have a unique solution to it. Each time the program is run the user receives a completely new challenge in getting to the end of the maze. These random numbers play into repetition with variation as well. The only thing that changes is the pattern of walls constructed. For each cell, a wall is either placed or not placed, and if it is placed, the only thing that changes is the orientation of it. All other attributes of the wall remain the same. 

To get through the maze itself, we decided to go with using different keys on the keyboard to change the direction. Whenever a Player stepped in any direction, an object was always left behind to create a “trail.” This way the Player would be able to see the incorrect paths already attempted, which would benefit the Player in getting through the maze faster. To implement the trail and the movement of the Player, the location of the Player and the object left behind to form the trail were both reset every time a key was pressed. If the player tried to move in a direction that a wall already was at, a sound would be generated. We were able to utilize the free sound effects found online in helping us create the noise when a wall was hit and a red box was dropped. Every key that the user pressed resulted in the Player moving one step, generated by changing the x or z position by 1. Using this logic, the outcome of a “Player moving through a maze” was successfully created. 

# Outcome
This project was able to highlight the four main components we were interested in: on-screen dynamics, design, randomness, and coding. For on-screen dynamics, the Player and the maze walls were able to interact with each other, as well as the Player and the objects left behind in the trail. The project also was related to user input, as the user had to move the Player around. There were also aspects of design, as the organization of the setting for the Player was an important factor. Since this was a maze project, line and space were also very important. As aforementioned, the maze generated each time was random in order to add to the appeal of playing this game multiple times. The unpredictable choices and randomness of the outputted maze with each run built into the random component that we added. Finally, this project added a coding aspect by relying heavily on our programming capabilities, with a complex maze algorithm and effects only made possible through programming. Overall, our team was able to successfully generate a maze game that would be exciting for any user to play.
